from build_ext import build_ext
import os
from distutils import log
from base import CommandMixin


class static_interpreter_override_mixin(CommandMixin):
    description = " as static builtins"
    user_options = [
        ('extra-compile-args=', 'x', "extra arguments to pass to the compiler"),
        ('extra-link-args=', 'y', "extra arguments to pass to the linker"),
        ('interpreter-filename=', None,
         "relative filename of output interpreter (default {build_lib}/static_interpreter)"),
    ]

    def initialize_options(self):
        super(static_interpreter_override_mixin, self).initialize_options()
        self.extra_compile_args = ""
        self.extra_link_args = ""
        self.interpreter_filename = None

    def finalize_options(self):
        super(static_interpreter_override_mixin, self).finalize_options()
        self.extra_compile_args = self.extra_compile_args.split()
        self.extra_link_args = self.extra_link_args.split()
        self.interpreter_filename = self.interpreter_filename or os.path.join(self.build_lib, "static_interpreter")

    # override, called from build_ext.run
    def build_extensions(self):
        # First, sanity-check the 'extensions' list
        self.check_extensions_list(self.extensions)

        built_objects = sum((self.build_extension_objects(ext) for ext in self.extensions), [])
        self.build_static_interpreter(built_objects)

    # from distutils build_ext.py build_ext.build_extension
    def build_extension_objects(self, ext):
        log.info("building objects for {0}".format(ext.name))
        sources = self.swig_sources(list(ext.sources), ext)
        extra_args = (ext.extra_compile_args or []) + (self.extra_compile_args or [])
        macros = ext.define_macros[:] + [(undef,) for undef in ext.undef_macros]
        objects = self.compiler.compile(sources,
                                        output_dir=self.build_temp,
                                        macros=macros,
                                        include_dirs=ext.include_dirs,
                                        debug=self.debug,
                                        extra_postargs=extra_args,
                                        depends=ext.depends)
        return objects

    def build_static_interpreter(self, objects):
        main_c = os.path.join(self.build_temp, "static_interpreter_main.c")
        with open(main_c, 'w') as f:
            f.write(self.generate_main_c([ext.name for ext in self.extensions]))
        objects += self.compiler.compile([main_c], output_dir=self.build_temp, debug=self.debug,
                                         extra_postargs=(self.extra_compile_args or []))

        log.info("building {0}".format(self.interpreter_filename))
        extra_args = sum((ext.extra_link_args or [] for ext in self.extensions), []) + (self.extra_link_args or [])
        self.compiler.link_executable(
            objects + sum((ext.extra_objects or [] for ext in self.extensions), []),
            self.interpreter_filename,
            libraries=sum((self.get_libraries(ext) or [] for ext in self.extensions), []),
            library_dirs=sum((ext.library_dirs or [] for ext in self.extensions), []),
            runtime_library_dirs=sum((ext.runtime_library_dirs or [] for ext in self.extensions), []),
            extra_postargs=extra_args,
            debug=self.debug,
            target_lang=self.compiler.detect_language(sum((ext.sources for ext in self.extensions), [])))

    def generate_main_c(self, ext_names):
        main_c_template = """/* Generated by {file} - do not edit! */
#include "Python.h"

#ifndef PyMODINIT_FUNC    /* declarations for DLL import/export */
#define PyMODINIT_FUNC void
#endif
{declare};

int main(int argc, char *argv[])
{{
    {init};
    Py_Initialize();
    PyRun_SimpleString({alias});
    int ret = Py_Main(argc, argv);
    Py_Finalize();
    return ret;
}}
"""
        alias_template = """
def alias_ext_imports(ext_names):
    class ImportAlias:
        def find_module(self, fullname, path=None):
            return self if fullname in ext_names else None
        def load_module(self, fullname):
            return __import__(fullname.rsplit('.', 1)[-1])
    import sys
    sys.meta_path.append(ImportAlias())

alias_ext_imports([{ext_names}])
del alias_ext_imports
"""
        basenames = [ext_name.rsplit('.', 1)[-1] for ext_name in ext_names]
        declare = ';\n'.join('PyMODINIT_FUNC init{ext}(void)'.format(ext=ext) for ext in basenames)
        init = ';\n    '.join('PyImport_AppendInittab("{ext}", init{ext})'.format(ext=ext) for ext in basenames)
        alias_code = alias_template.format(ext_names=', '.join('\'{ext}\''.format(ext=ext) for ext in ext_names))
        alias = '\n        '.join('"{line}\\n"'.format(line=line) for line in alias_code.split('\n'))
        return main_c_template.format(file=os.path.abspath(__file__), declare=declare, init=init, alias=alias)


def _get_cython_build_ext_static_interpreter():
    from Cython.Distutils.__init__ import build_ext as cython_build_ext

    class cython_build_ext_static_interpreter(static_interpreter_override_mixin, cython_build_ext):
        description = cython_build_ext.description + static_interpreter_override_mixin.description
        user_options = cython_build_ext.user_options + static_interpreter_override_mixin.user_options

        def __init__(self, *args, **kwargs):
            cython_build_ext.__init__(self, *args, **kwargs)

        def build_extensions(self):
            for ext in self.extensions:
                ext.sources = self.cython_sources(ext.sources, ext)
            super(cython_build_ext_static_interpreter, self).build_extensions()

    return cython_build_ext_static_interpreter


class build_ext_static_interpreter(static_interpreter_override_mixin, build_ext):
    """
    Build a Python interpreter with all ext_modules linked in statically and imported.
    This is useful when working with analysis tools e.g. gcov that don't work with shared library modules.
    """
    description = build_ext.description + static_interpreter_override_mixin.description
    user_options = build_ext.user_options + static_interpreter_override_mixin.user_options

    def run(self):
        if self.uses_cython():
            # Cython source - use cython's build_ext
            log.info("This project uses Cython, fetching builder egg")
            self.fetch_build_eggs(['Cython'])

            cbe_class = self.distribution.cmdclass['cython_build_ext'] = _get_cython_build_ext_static_interpreter()
            cbe = self.distribution.command_obj['cython_build_ext'] = cbe_class(self.distribution)
            cbe.inplace = self.inplace
            cbe.extra_compile_args += ' '.join(self.extra_compile_args)
            cbe.extra_link_args += ' '.join(self.extra_link_args)
            cbe.interpreter_filename = self.interpreter_filename
            cbe.cython_line_directives = True   # HACK, ext_gcov_test needs this

            self.run_command('cython_build_ext')
        else:
            super(build_ext_static_interpreter, self).run()
